package com.github.eclipse.dsl4eclipse.utils;import java.util.ArrayList;import org.eclipse.swt.widgets.Display;import org.eclipse.ui.PlatformUI;public abstract class UIThreadRunnable implements Runnable {	/** the display on which runnables must be executed. */	protected final Display display;	/**	 * A flag to denote if the runnable should execute asynchronously.	 */	private final boolean async;	/**	 * Runs synchronously in the UI thread.	 * 	 * @param display	 *            The display to be used.	 */	private UIThreadRunnable(Display display) {		this(display, false);	}	/**	 * A private contructor use to create this object.	 * 	 * @param display	 *            The display to use.	 * @param async	 *            if the thread should run asynchronously or not.	 * @see Display#syncExec(Runnable)	 * @see Display#asyncExec(Runnable)	 */	private UIThreadRunnable(Display display, boolean async) {		this.display = display;		this.async = async;	}	/**	 * This method is intelligent to execute in the UI thread.	 */	public void run() {		if ((display == null) || display.isDisposed())			return;		if (!isUIThread()) {			if (async)				display.asyncExec(runnable());			else				display.syncExec(runnable());		} else			doRun();	}	private static boolean isUIThread() {		return isUIThread(display());	}	private static boolean isUIThread(Display display) {		return display.getThread() == Thread.currentThread();	}	/**	 * A runnable instance that is used internally.	 * 	 * @return The runnable instance.	 */	private Runnable runnable() {		final Runnable runnable = new Runnable() {			public void run() {				doRun();			}		};		return runnable;	}	/**	 * Performs the run in the UI Thread.	 * <p>	 * This MUST be invoked in the UI thread.	 * </p>	 */	protected abstract void doRun();	/**	 * Executes the {@code toExecute} on the UI thread, and blocks the calling	 * thread.	 * 	 * @param <T>	 *            the type of the result.	 * @param toExecute	 *            the runnable to execute.	 * @return the result of executing result on the UI thread.	 * @throws Exception 	 */	public static <T> T syncExec(final Result<T> toExecute) throws Exception {		return syncExec(display(), toExecute);	}	/**	 * Executes the {@code toExecute} on the display thread, and blocks the	 * calling thread.	 * 	 * @param <T>	 *            the type of the result.	 * @param display	 *            the display on which toExecute must be executed.	 * @param toExecute	 *            the runnable to execute.	 * @return the object result of execution on the UI thread.	 * @throws Exception 	 */	public static <T> T syncExec(Display display, final Result<T> toExecute) throws Exception {		final ArrayList<T> arrayList = new ArrayList<T>();		final ArrayList<Exception> exceptions = new ArrayList<Exception>();		new UIThreadRunnable(display) {			protected void doRun() {				try {					arrayList.add(toExecute.run());				} catch (Exception e) {					exceptions.add(e);				}			}		}.run();		exceptions(exceptions);		return arrayList.get(0);	}	private static void exceptions(final ArrayList<Exception> exceptions)			throws Exception {		if (!exceptions.isEmpty()){			throw exceptions.get(0);		}	}	/**	 * Executes the {@code toExecute} on the display thread, and blocks the	 * calling thread.	 * 	 * @param <T>	 *            the type of the result.	 * @param toExecute	 *            the runnable to execute.	 * @return the object result of execution on the UI thread.	 * @throws Exception 	 */	public static <T> T[] syncExec(final ArrayResult<T> toExecute) throws Exception {		return syncExec(display(), toExecute);	}	/**	 * Executes the {@code toExecute} on the display thread, and blocks the	 * calling thread.	 * 	 * @param <T>	 *            the type of the result.	 * @param display	 *            the display on which toExecute must be executed.	 * @param toExecute	 *            the runnable to execute.	 * @return the object result of execution on the UI thread.	 * @throws Exception 	 */	public static <T> T[] syncExec(Display display, final ArrayResult<T> toExecute) throws Exception {		final ArrayList<T[]> arrayList = new ArrayList<T[]>();		final ArrayList<Exception> exceptions = new ArrayList<Exception>();		new UIThreadRunnable(display) {			protected void doRun() {				try {					arrayList.add(toExecute.run());				} catch (Exception e) {					exceptions.add(e);				}			}		}.run();		exceptions(exceptions);		return arrayList.get(0);	}	/**	 * Executes the {@code toExecute} on the UI thread, and blocks the calling	 * thread.	 * 	 * @param toExecute	 *            the runnable to execute.	 * @throws Exception 	 * @since 1.0	 */	public static void syncExec(final VoidResult toExecute) throws Exception {		syncExec(display(), toExecute);	}	/**	 * Executes the {@code toExecute} on the display thread, and blocks the	 * calling thread.	 * 	 * @param display	 *            the display on which toExecute must be executed.	 * @param toExecute	 *            the runnable to execute.	 * @throws Exception 	 */	public static void syncExec(Display display, final VoidResult toExecute) throws Exception {		final ArrayList<Exception> exceptions = new ArrayList<Exception>();		new UIThreadRunnable(display) {			protected void doRun() {				try {					toExecute.run();				} catch (Exception e) {					exceptions.add(e);				}			}		}.run();		exceptions(exceptions);	}	/**	 * Executes the {@code toExecute} on the UI thread asynchronously, and does	 * not block the calling thread.	 * 	 * @param toExecute	 *            the runnable to execute.	 * @since 1.0	 */	public static void asyncExec(final VoidResult toExecute) {		asyncExec(display(), toExecute);	}	private static Display display() {		return PlatformUI.getWorkbench().getDisplay();	}	/**	 * Executes the {@code toExecute} on the UI thread asynchronously, and does	 * not block the calling thread.	 * 	 * @param display	 *            the display on which toExecute must be executed.	 * @param toExecute	 *            the runnable to execute.	 */	public static void asyncExec(Display display, final VoidResult toExecute) {		new UIThreadRunnable(display, true) {			protected void doRun() {				try {					toExecute.run();				} catch (Exception e) {					e.printStackTrace();				}			}		}.run();	}}